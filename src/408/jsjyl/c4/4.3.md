---
title: 4.3 程序的机器级代码表示
---

## 1. 地址码的作用

指令由操作码和地址码组成(回顾)

地址码指明数据——寄存器、主存、直接给出

根据数据的不同存放位置，地址码有不同的形式

## 1.1 存放在寄存器中

寄存器只要是以E开头，就是32bit

EAX EBX ECX EDX：==通用寄存器==(X=未知)，什么数据都能存

E=Extended

AX BX CX DX：==通用寄存器==，但只使用低16bit

AH BH CH DH：只使用AX BX CX DX的高8bit

AL BL CL DL：只使用低8bit

ESI EDI： ==变址寄存器==(I=Index,S=Source, D=Destination)

只能固定使用32bit

>变址寄存器可用于线性表和字符串的处理

EBP：==堆栈基指针==(Base Pointer)

ESP：==堆栈定指针==(Stack Pointer)

堆栈寄存器可用于函数调用(后续展开)

只能固定使用32bit

### 1.2 存放在主存中

在汇编指令中，给出读写长度、主存地址

读写长度：

dword ptr——双字，32bit

word ptr——单字，16bit

byte ptr——字节，8bit

若未指明内存读写长度，默认32bit

中括号[]指明一个地址，如word ptr[114514]

如[ebx]这样的形式是寄存器间接寻址

mov eax dword ptr [ebx]：将ebx所指的主存地址的32bit复制到eax寄存器中

mov eax, dword ptr [ebx+8] 将ebx+8所指主存地址的32bit复制到eax寄存器中

### 1.3 指令直接给出

直接在地址码中给出常量，即"立即寻址"

可用十进制表示，也可用十六进制(常以h结尾)

## 2. 常用汇编语言指令格式

### 2.1 算术运算

==d==estination 目的地 (d 目的操作数)

==s==ource 来源地 (s 源操作数)

目的操作数 d 不可以是常量，只能是主存或寄存器

| 功能 | 汇编指令 | 注释 |
| --- | ------- | --- |
| 加法 | add d, s | 计算d+s，结果存入d |
| 减法 | sub d, s | 计算d-s，结果存入d |
| 乘法 | mul d,s <br> imul d, s | 无符号数d\*s，乘积存入d<br>有符号数d\*s，乘积存入d |
| 除法 | div s <br> idiv s<br>. | 无符号数除法 edx:eax/s，商存入eax，余数存入edx<br>有符号数除法edx:eax/s，商存入eax，余数存入edx<br> 此处edx:eax是位扩展的意思，被除数提前放在寄存器中 |
| 取负数 | neg d | 将d取负数，结果存入d |
| 自增++ | inc d | d++，结果存入d|
| 自减-- | dec d | d--，结果存入d |

\<reg\> 操作数来源于任意寄存器

<mem\> 操作数来源于任意主存地址

<con\> 常数


x86中不允许两个操作数均来自于主存

### 2.2 逻辑运算

| 功能 | 汇编指令 |
| --- | ---- |
| 与 | and d, s |
| 或 | or d,s |
| 非 | not d |
| 异或 | xor d, s |
| 左移 | shl d, s (shift left)|
| 右移 | shr d, s (shift right)|

### 2.3 其他指令

用于实现分支、循环结构：cmp、test、jmp、jxxx

用于实现函数调用：push、pop、call、ret

用途实现数据转移：mov


## 3. AT&T格式与Intel格式的区别

在AT&T格式，未标明长度也默认32bit

| | AT&T格式 | Intel格式 |
| --- | --- | --- |
| 目的操作数d与原操作数s | op s,d， 左进右 | op d,s ，右进左 |
| 寄存器表示 | mov %eax, %ebx <br>寄存器前必须要加% | mov ebx , eax <br> 直接给寄存器名即可 |
| 立即数表示 | mov $985, %eax<br>立即数前必须要加'$' | mov eax,985<br>直接写数字即可|
| 主存地址的表示 | mov %eax, (af996h)<br> 用小括号表示 | mov [af996h] ,eax<br>用中括号表示 |
| 读写长度的表示 | movb $5 (af996h)<br> movw $5 (af996h)<br>movl $5 (af996h)<br>addb $4 (af996h)<br>指令后加b、w、l分别表示<br>byte、word、dword | mov byte ptr [af996h], 5<br>mov word ptr [af996h], 5<br>mov dword ptr [af996h], 5<br>add byte ptr [af996h], 4<br>在主存地址前说明读写长度<br>. |
| 偏移量表示 | movl -8(%ebx), %eax <br>偏移量(基址)<br><br>movl 4(%ebx, %ecx, 32), %eax<br>偏移量(基址,变址,比例因子) | mov eax, [ebx-8]<br>[基址+偏移量] <br><br>mov eax, [ebx + ecx\*32+4]<br>[基址+变址\*比例因子+偏移量]|

## 4. 选择语句的机器级表示

> Intel x86中，PC通常被称为IP(Instruction Pointer)

无条件转移指令：

jmp \<地址> #PC无条件转移至\<地址>

jmp 128 #\<地址>可以用常数给出

jmp eax #\<地址>可以来自于寄存器

jmp [999] #\<地址>可以来自于主存

jmp NEXT #\<地址>可以用"标号"锚定

汇编语言中，可以用"标号"锚定位置

特征：有冒号，名字可以自己取

例如：jmp NEXT

NEXT:


### 4.2 条件转移指令

| 指令 | 功能 |
| --- | ---- |
| je \<地址> | 若a==b则跳转 |
| jne \<地址> | 若a!=b则跳转 |
| jg \<地址> | 若a>b则跳转 |
| jge \<地址> | 若a>=b则跳转 |
| jl \<地址> | 若a<b则跳转 |
| jle \<地址> | 若a<=b则跳转 |

:::tip
条件转移指令一般要和cmp指令一起使用，如

cmp eax, ebx

jg NEXT;

cmp的数可能来自寄存器/主存/常量
:::

:::tip cmp的底层原理
本质是进行减法运算，并生成标志位OF,ZF,CF,SF
:::

## 5. 循环语句的机器级表示

用条件转移指令实现循环，需要4个部分构成：

1. 循环前的初始化
2. 是否直接跳过循环(已不满足循环条件)
3. 循环主体
4. 是否继续循环

### 5.1 用loop指令实现循环

mov ecx , 500 #loop指令默认使用ecx作为循环计数器
Looptop: #循环的开始
...
某些处理
...
loop Looptop #ecx--，若ecx!=0，跳转到Looptop












