---
title: 4.2 指令的寻址方式
---
## 1. 指令寻址

程序计数器 PC(Program Counter)：指明下一条指令的存放地址

指令寻址：寻找下一条预执行指令的地址

### 1. 顺序寻址

假设主存按字节编址

若系统采用定长指令字结构，则PC每次+"1"(单指令字长)


若该系统采用变长指令字结构，则PC每次+n(该指令的总字长)

CPU会根据指令操作数的类型，CPU可能还要进行多次访存


最终结论：(PC)+"1"→PC


:::tip
这里的1理解为1个指令字长，实际加的值会因指令长度、编址方式不同
:::




### 2. 跳跃寻址

由转移指令指出

JMP：无条件转移，把PC中的内容改成x

绝对转移：转移码直接指出转移目标地址

相对转移：地址码指出转移目的地址相对于当前PC值的偏移量

:::tip
由于CPU总是根据PC的内容去主存取指令，因此转移指令执行的结果是修改PC值，下一条指令仍然通过PC给出
:::

## 2. 数据寻址

数据寻址：确定本条指令的地址码指明的真实地址

说白了就是找到每个数据的地址，开盒！

通常来说，会在指令的地址码前加上用来标识寻址特征的比特位

现在，地址码分为`寻址特征`和`形式地址(A)`

形式地址不代表操作数的真实地址

对于多地址指令，每个形式地址前都要添加寻址特征

形式地址结合寻址特征，可以计算出操作数在存储器中的真实地址，这种地址称为`有效地址(EA)`

### 1. 直接寻址

指令字中的形式地址A就是操作数的`真实地址(EA)`，即`EA=A`

操作过程中共访存3次

优点：简单，指令执行阶段仅访问一次主存，不需要专门计算操作数的地址

缺点：A的位数决定了该指令操作数的寻址范围；操作数的地址不易修改

### 2. 间接寻址

形式地址给出的是操作数有效地址所在存储单元的地址，也就是<u>操作数地址的地址</u>，即`EA=(A)`

共访存3次

有时候也可能有多次间接寻址(隔着套娃呢)

优点：
+ 可扩大寻址范围(有效地址EA的位数大于形式地址A的位数)
+ 便于编制程序(用间接寻址可以方便地完成子程序返回)


























