---
title: 2.2 运算方法和运算电路
---
## 1. 基本运算部件

算术运算：对数字进行运算，如加减乘除、幂次方

逻辑运算：对逻辑值(真/假)进行运算，如：与、或、非、异或

无论是算术运算，还是逻辑运算，都要有输入、输出

### 1. 与运算

与 AND

表达式：$Y=A·B$，也可简写为$Y=AB$

![与门](image-6.png =400x)

| A | B | Y |
| - | - | - |
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

必须全为真，才是真

### 2.或运算

或 OR

表达式：$Y=A+B$

![或门](image-7.png =400x)

| A | B | Y |
| - | - | - |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 1 |

只要有一个真，就全是真

### 3. 非运算

非 NOT

$Y=\bar{A}$



![非门](image-8.png =400x)

| A | Y |
| - | - |
| 0 | 1 |
| 1 | 0 |

### 4. 复合逻辑运算：与非

与非 NAND

Y=$\overline{A·B}$

![与非门](image-9.png =400x)

| A | B | Y |
| - | - | - |
| 0 | 0 | 1 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

和**与门**的输出结果相反


### 5.符合逻辑运算：或非

或非 NOR

$Y=\overline{A+B}$

![或非门](image-10.png =400x)

| A | B | Y |
| - | - | - |
| 0 | 0 | 1 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 0 |

和**或门**的输出结果相反



### 6.复合逻辑运算：异或

异或 XOR

$Y=A\bigoplus B(=\bar{A}B+A\bar{B})$

![异或门](image-11.png =400x)

| A | B | Y |
| - | - | - |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

只有当两个输出值不同时才输出1

### 7.复合逻辑运算：同或

同或 XNOR

$Y=A\bigodot B(=\overline{A\bigoplus B})$

![同或门](image-12.png =400x)

| A | B | Y |
| - | - | - |
| 0 | 0 | 1 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

效果就是在异或门上接了个非门 

有些地方会翻译成异或非门

:::tip 异或的妙用
n个bit进行异或，若有奇数个1，则异或结果为1；若有偶数个1，则异或结果为0
:::






:::tip 封装思想
屏蔽电路部件的内部实现细节，仅对外暴露输入/输出引脚

使用者仅需关心该部件的功能即可
:::

### 8. 补充1 门电路的变形画法

![多个输入端](image-13.png)

### 9. 补充2 逻辑运算的优先级与常见公式

优先级：非>与>或

可以类比乘方、乘法、加法之间的关系

反演律：$\overline{A+B}=\bar{A}·\bar{B}$

$\overline{A·B}=\bar{A}+\bar{B}$

逻辑表达式是对电路的数学化描述

### 10. 多路选择器

![多路选择器](image-14.png)

作用：在多个输入数据中，只允许其中一个数据通过MUX

通常用梯形来表示，更长的一边是输入端，更短的一边是输出端

若有k个输入，则控制信号的位数是$,\geq \lceil\log_2k\rceil bit$

控制信号决定了第x位输入可以通过
 
有的多路选择器可能会预留一个控制信号(状态)，用于拦截所有输入

### 11. 三态门

![三态门](image-15.png)

根据控制信号决定是否让输入的数据通过，0为阻拦，1为通过
 
仅有一个输入端和一个输出端

有些时候可能会出现在三态门的一端加一个"小圆圈"，增加非运算的效果

非门没有控制信号的通过与否，只修改信号的是非

## 2. 加法器

n位整数可以被拆价为n个1位加法

分别为：

$A_i$：被加数的本位

$B_i$：加数的本位

$C_{i-1}$：来自低位的进位

$S_i$：本位和

输入：$A_i,B_i,C_{i-1}$

输出：$S_i=A_i\bigoplus B_i\bigoplus C_{i-1}$(输入中有奇数个1时输出1)

$C_i=A_i·B_i+(A_i\bigoplus B_i)C_{i-1}$(输入中至少有2个1时输入1) 

![一位全加器 (FA)](image-17.png)

若把n个以为全加器串接起来，就可以进行两个n bit树的相加(即每个进位输入输出互相串联)

不足之处：进位信息是串行产生的，计算速度取决于进位产生和传递的速度

电信号达到稳态需要一定时间，进位产生速度会有延迟

串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级产生的

这种加法器输入**并行加法器**

![不用关心内部具体功能分类](image-18.png)

从进位方式来看，又输入**串行进位加法器**

并行进位的并行加法器：所有进位信息都是同时发生的，几乎没有延迟。

特点：运算速度比串行进位的并行加法器更快

### 带标志位的加法器

有时候还需要关心加法器的运算结果是正是负

![带标志位的加法器](image-19.png)

+ **OF(Overflow Flag)：溢出标志**，用于判断带符号数加减运算是否溢出

OF=1 溢出； OF=0 未溢出

$OF=C_n\bigoplus C_{n-1}$，最高位的进位异或次高位的进位，反映带符号数加减运算是否溢出

+ **SF(Sign Flag)：符号标志**，用于判断带符号数加减运算结果的正负性

SF=1 结果为负；SF=0 结果为正

$SF=S_n$，直接取运算结果的最高位(符号位)，反映带符号数加减运算的正负性

+ **ZF(Zero Flag)：零标志**，用于判断加减运算结果是否为0

ZF=1 结果为0； ZF=0 结果不为0

ZF=$\overline{S_n+\cdots+S_2+S_1}$，当且仅当运算结果所有比特位全0时，ZF才为1

+ **CF(Carry Flag)：进位/借位标志**，用于判断无符号数加减运算是否溢出
CF=1 溢出；CF=0 未溢出

$CF=C_{out}\bigoplus C_{in}=C_n\bigoplus C_0$，反映无符号数加减运算是否溢出





































