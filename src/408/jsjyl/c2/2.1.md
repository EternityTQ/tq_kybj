---
title: 2.1 数制与编码
---

## 1. 进制计数制及其相互转换

罗马数字——基于加法思想的计数方法

阿拉伯数字——十进制

**位权**：数值上每一位代表的数值大小，即比如1000,100...等权重

**基数**：每个数码位所用到的不同符号的个数，r进制的基数为r

二进制：101.1$\to 1·2^2+0·2^1+1·2^0+1·2^{-1}$

:::tip 为什么计算机使用二进制？
1. 可使用两个稳定状态的物理器件表示
2. 0，1正好对应逻辑值假，真。方便实现逻辑运算
3. 可以很方便的使用逻辑门电路实现算术运算
:::

### 二进制与八进制

3位为1组，每组互相转换

### 二进制与十六进制

4位符号为一组，每组互相转换

二进制的表示方式：101010B

十六进制：1652H 0x1652

十进制：1652D

### 十进制→任意进制

分为整数部分和小数部分分别处理

对整数部位每次除以目标进制r，所得余数即为最低进制的数码位

例子：75 十进制→二进制

75/2=37.. 1

37/2=18.. 1

18/2=9 ..0

9/2=4 ..1

4/2=2 ..0

2/2=1 ..0

1/2=0 ..1

从下往上数即为结果：1001011

小数部分每次**乘以**目标进制r，所得结果的整数部分即为对应进制的数码位

例子：0.4
0.4*2=0.8 0

0.8*2=1.6 1

0.6*2=1.2 1

0.2*2=0.4 0

从上往下数即为结果，即0.0110

也可以用拼凑法(直接看对应的数值，抓阄)


整数一定可以转换为二进制，但是小数部分不一定可以

### 真值与机器数

真值：符合人类习惯的数字

机器数：数字实际存到机器里的形式

## 2. 定点数的表示

定点数：小数点的位置固定

浮点数：小数点的位置不固定，就是科学计数法

:::tip
在现代计算机中，通常用补码整数表示整数，用原码小数表示浮点数的尾数部分，用移码表示浮点数的阶码部分
:::

### 1.无符号数

整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值

表示范围：8位二进制数：$2^8$种不同的状态，范围为$0\~2^8-1$

n位无符号数的表示范围为$0\~2^n-1$

通常只有无符号整数，没有无符号小数

无符号整数能表示的最大数比有符号整数要大



### 2. 原码

用尾数表示真值的绝对值，符号位0/1表示正负

==若机器字长为n+1位，则位数占n位==

![](image.png =500x)

数值部分也可以叫尾数

**定点小数**：定点小数是纯小数，约定小数点位置在符号位之后

**定点整数**：定点整数是纯整数，约定小数点位置在有效数值最低位置后

小数点位置均为隐含

如果没有写明机器字长，则在写原码时可以忽略开头的0

记为$[X]_\text{原}=1,00110$

>逗号的作用是用来标记符号位

若机器字长n+1位，则原码整数的表示范围为：

$$-(2^n-1)\leq x\leq 2^n -1$$



原码表示定点小数范围：

$$-(1-2^{-n})\leq x\leq 1-2^{-n}$$

==真值0有+0和-0两种形式==

(也就是00000000和10000000)

### 3. 反码

若符号位为0，则反码与原码相同

若符号位为1，则反码是原码的数值位全部取反

x=+19D 原码：0,0010011

反码：0,0010011

X=-19D 原码：1,0010011

反码：1,1101100

反码的表示范围和原码一致

:::warning
反码只是原码转变为补码的一个中间状态，没有什么用

计算机不会使用反码进行运算
:::

+0和-0同样有两种表示形式

00000000和11111111
### 4. 补码

正数的补码：原码
负数的补码：反码末尾+1(要考虑进位)

![](image-1.png =500x)

==补码的真值0只有一种表示形式==

![](image-3.png =500x)

规定$[X]_{\text{补}}=1,0000000$表示$x=-2^7$

补码整数的表示范围为：

$$-2^n\leq x\leq x^n-1$$

补码小数的表示范围为：
$$-1\leq x\leq 1-2^{-n}$$
:::tip
负数补码的数值部分越大，其真值越大(负号后的数值越小)
:::
:::tip 几个特殊数据的补码表示
$[+0]_{\text{补}}=[-0]_{\text{补}}=0,000...0$

$[-1]_\text{补}=2^{n+1}-1=1,111...1$

$[2^n-1]_{\text{补}}=0,11...1$，即n+1位补码所能表示的最大整数

$[-2^n]_{\text{补}}=1,00...0$，即n+1位补码所能表示的最小整数
:::

:::tip

![负数原码和负数补码相互转换的方法](image-5.png =500x)

:::

补码可以用于只用加法器来计算带负号的式子，让减法操作变为加法操作，节省硬件成本


模-a的绝对值=a的补数

:::tip 变形补码

变形补码，又称模4补码，是一种采用双符号位的补码表示，主要用于判断是否产生符号位溢出


也就是符号位用2位数表示，00表示正数，11表示负数

主要用在执行算术运算的ALU中
:::

:::tip 由x的补码快速求-x的补码

直接将符号位和数值位全部取反，末位+1，即为结果

:::
### 5. 移码

移码就是在真值X上加上一个常数(**偏置值**)，相当于X在数轴上向正方向偏移了若干单位

若这个常数为$2^n$，则移码就是在补码的基础上将符号位取反

==移码只能用于表示整数==

![](image-4.png =500x)

移码整数的表示范围与补码相同

移码表示的整数可以很方便的对比大小，即它保留了数据原有的大小顺序

:::tip
原码和反码的真值0有两种表示

补码和移码的真值0只有一种表示，但是这两者可以多表示一个负数
:::

## 3. C语言中的整数类型及类型转换

:::tip
使用unsigned声明的整数是无符号整数

C语言中的定点整数是用“补码”存储的
:::


```c
short x=-4321;
unsigned short y=(unsigned short)x;

//x：1110 1111 0001 1111，真值：-4321
//y：1110 1111 0001 1111，真值：61215
```
无符号数与有符号数：不改变数据内容，改变解释方式

```c
int a=165537,b=-34991;
short c=(short)a,d=(short)b;

```
长整数变短整数：高位截断，保留低位

```c
short x=-4321;
int m=x;
unsigned short n=(unsigned short)x;
unsigned int p=n;
```
短整数变长整数：符号扩展(有符号数以1填充高位，无符号数以0填充高位)

## 4. 长度扩展

因为ALU的位数是固定的，所以运算前可能需要把短数据扩展为长数据

通用寄存器的位数是固定的，把数据存入寄存器时，可能需要进行长度扩展

**零扩展**

适用于无符号整数，用0扩展高位

01011010→00000000 01011010

**符号扩展**

适用于带符号整数，用符号位扩展高位

1,0100110→1,11111111 0100110








