---
title: 5.3 二叉树的遍历与线索二叉树
---

## 1. 二叉树的遍历

遍历：按照某种次序把所有结点都访问一遍

层次遍历：基于树的层次特性确定的次序规则

二叉树的递归特性：

1. 要么是空二叉树
2. 要么是由"根节点+左子树+右子树"组成的二叉树

先序遍历：根左右 (也可以叫做先根遍历)

中序遍历：左根右

后序遍历：左右根

注意中序遍历要先遍历左子树再遍历根节点，手算的时候千万别算快了

先序遍历->前缀表达式

中序遍历->中缀表达式(需要加界限符)

后序遍历->后缀表达式

用递归算法实现二叉树的遍历如下：
```c++
void PreOrder(Bitree* t){//先序遍历
    if(t!=NULL){
        visit(t);
        PreOrder(t->left);
        PreOrder(t->right);
    }
}

void InOrder(Bitree* t){//中序遍历
    if(t!=NULL){
        PreOrder(t->left);
        visit(t);
        PreOrder(t->right);
    }
}

void PostOrder(Bitree* t){//后序遍历
    if(t!=NULL){
        PreOrder(t->left);
        PreOrder(t->right);
        visit(t);
    }
}
```

算法中，每个结点都会被"路过三次"，也就是三种遍历顺序的差别了

非递归遍历算法的难度较大，统考要求不高，略



层次遍历通常借助辅助队列

太熟悉了，不多写了！

## 2. 由遍历序列构造二叉树

如果只给定前/中/后/层 序遍历序列中的一种，不能唯一确定一颗二叉树

一般是其他三种+中序遍历，两种遍历才能确定一颗二叉树

通过先序/后序最先/最后出现的结点必是子树的根节点来判断，加上中序遍历的顺序，就可以推出整个二叉树

## 3. 线索二叉树

遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列

该序列中，每个结点(除了头尾)都有一个直接前驱和一个直接后继

线索二叉树的引入是为了加快查找结点前驱和后继的速度

n个结点的二叉树，有n+1个空链域，可以用来记录前驱、后继的信息

![](/assets/img/shujv5.jpg =500x)

规定：若无左子树，则其lchild指向其前驱节点；若无右子树，则rchild指向其后继结点

指向前驱、后继的指针称为线索

还需要多加两个标志域，用来标识指针域指向的是左右孩子还是还是前驱后继

将二叉树改造为线索二叉树后，其存储结构称为"线索链表"

### 线索化二叉树

用代码实现的话，就是要多加一个指向前一个遍历结点的指针pre，然后随时处理



每一次遍历，都检查指针p的左子树是否为空，如果是，则指向pre

然后同时检查pre的右子树是否为空，如果是，指向p


线索化分为中序线索化、先序线索化和后序线索化


注意：先序线索化每次还需要判断左节点是不是前驱线索，防止死循环

同时，还需要注意最后一个结点的rchild、rtag的处理

### 线索二叉树找前驱后继

中序线索二叉树：

后继：若结点的rtag为1，则直接返回右结点

否则，返回该结点的右子树中，最左下的结点(也就是一路向左)

前驱：若结点的ltag为1，则直接返回左节点

否则，返回该结点的左子树中，最右下的结点(也就是一路向右)

先序线索二叉树：

后继：若结点的rtag为1，则直接返回右结点

否则，按顺序返回第一个存在的：左孩子、右孩子

前驱：若结点的ltag为1，则直接返回左节点

否则，无法快速找到其前驱，除非从头进行一次遍历

后序线索二叉树：

后驱：若结点的rtag为1，则直接返回右结点

否则，无法快速找到其后继，除非从头进行一次遍历

前驱：若结点的ltag为1，则直接返回左节点

否则，按顺序返回第一个存在的：右孩子、左孩子







