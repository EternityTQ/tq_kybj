---
title: 6.3 图的遍历
---
## 1. 广度优先遍历

优先搜索与当前结点相邻的结点

BFS(Breadth-First-Search)需要标记已搜索的结点(DFS也一样)

:::tip
1. 找到与一个顶点相邻的所有顶点
2. 需要一个辅助数组来标记哪些顶点被访问过
3. 需要一个辅助队列
:::

具体流程：

1. 访问队首顶点
2. 将与队首顶点相邻的所有，尚未访问过的，顶点加入队尾，然后将加入队尾的顶点设为已访问
3. 访问完毕后，重复1\~3步骤
4. 当队列已空但所有点尚未遍历完毕时，搜索辅助数组下一个FALSE的顶点

:::tip
同一个表的邻接矩阵表示方式唯一，因此广度优先遍历序列唯一；

同一个表的邻接表表示方式不唯一，因此广度优先遍历序列不唯一；
:::

:::tip
广度优先算法是一个分层的查找过程
:::

### 复杂度

对于邻接矩阵，完成BFS的时间复杂度为$O(|V|^2)$

对于邻接表，完成BFS的时间复杂度为$O(|V|+|E|)$

算法开销主要来源于访问各个点和各个边

### 广度优先生成树

在广度优先遍历过程中的遍历过程称为广度优先生成树

:::tip
同一个表的邻接矩阵表示方式唯一，因此广度优先遍历序列唯一，广度优先生成树也唯一；

同一个表的邻接表表示方式不唯一，因此广度优先遍历序列不唯一，广度优先生成树也不唯一；
:::

## 2. 深度优先遍历

DFS目的是尽可能优先深入搜索一个图

同样需要一个辅助数组来记录是否已访问

但是，DFS需要的是一个辅助栈

具体流程：

1. 访问栈首顶点
2. 将栈首顶点的下一个与其连接的，尚未访问过的顶点压入栈中
3. 当所有与其相邻的顶点都被访问过后，弹出栈首顶点
4. 重复1-3步骤
5. 调用栈空后，寻找辅助队列中下一个尚未访问过的顶点，压入栈中
### 复杂度
空间复杂度：来自于递归调用栈

为$O(1)~O(|V|)$

没有特殊说明，都答最坏情况

时间复杂度：访问各结点+探索各条边所需时间

邻接矩阵：$O(|V|)$

邻接表：$O(|V|+|E|)$

### 深度优先搜索树
就是深度优先遍历的遍历过程

生成树/生成树林不唯一
## 图的遍历与图的连通性

如果一个无向图是联通的，则从任意一个结点出发，仅需一次DFS/BFS就能遍历所有结点；如果不是联通的，则只能遍历其中一个连通分量

即，DFS/BFS的调用次数=连通分量树

对于有向图，如果初始顶点到其他顶点都有路径，则只需调用一次BFS/DFS

对于强连通图，从任何结点出发仅需调用一次BFS/DFS














