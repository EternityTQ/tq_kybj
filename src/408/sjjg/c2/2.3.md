---
title: 2.3 线性表的链式表示
---

## 单链表

线性表的链式存储又称*单链表*

优点：不要求大片连续空间，**改变容量方便**，插入删除操作不需要移动元素，只需要修改指针
缺点：**不支持随机存取**，要花费一定额外空间存放地址(指针)

单链表的定义如下

:::details 定义代码

```c
struct LNode{//结点
    ElemType data;//数据域
    struct LNode *next;//指针域
}

struct LNode* p = (struct LNode *)malloc(sizeof(struct LNode))

//或者...可以重命名来缩短长度

typedef struct LNode LNode;

LNode* p = (LNode *)malloc(sizeof(LNode));

//甚至...

struct LNode_{
    ElemType data;
    struct LNode_ *next;
}LNode, *LinkList//在这里相当于直接用typedef定义


```

:::

通常使用头指针L(或head等)来标识一个单链表，指出链表的起始地址，头指针为NULL时表示一个空表

空表判断：L==NULL

头指针为NULL时，不太方便

为了操作上的方便，通常在第一个结点前附加一个结点，称为**头结点**

头结点可以不设任何信息，但是可以记录表长等信息

空表判断：L->next==NULL

<u>头结点与头指针的关系</u>:不管带不带头结点，头指针永远指向链表的第一个结点；但头结点是存在头结点的链表中第一个结点，结点内通常不存储信息

引入头结点后，可以带来<u>两个优点</u>：
1. 由于第一个数据结点的位置被存放在头结点的**指针域**中，因此在链表的第一个位置上的操作和其他位置一致，无需特殊处理
2. 无论链表是否为空，头指针永远指向头结点的非空指针(空表中，头结点的指针域为空)，因此空表和非空表的处理得到了统一


## 单链表的基础操作 

### 求表长
直接从头结点遍历整个表，遍历一次计数一次，直到当前头结点的指针域为NULL即可

### 插入

a->b->c->d

此时e想插入到a和b中间

那么就是

```c
e->next=a->next;
a->next=e;
```

注意顺序不能颠倒

插入实际上是让新插入的元素称为单链表中**新的第i个**元素

当遍历至空指针时，程序停止

当不带头结点且插入位置为1时，需要创建新指针，让头指针指向新指针，并让新指针的指针域指向旧头指针

**指定节点的前插区域**
>前插操作：在p结点前插入元素e

直接从头结点开始找，找到指定节点后再进行插值

前插操作均可以转换为后插操作

\>又或者....

直接插入一个新的结点，将该结点的值改为p结点的值，然后将原p结点的值改为e
```c
s->next=p->next;
p->next=s;//插入结点

temp=p->data;
p->data=s->data;
s->data=temp;//交换

```

>这也太妙了


### 删除

按位序删除，删除表L中第i个位置的元素

L -> head -> p1 -> p2 -> p3

删除p2，操作指针指向p1，那么有：

```c
*q = p->next;
p->next=*q->next;
free(q);
```

**删除指定节点*p**

与插入的前插操作相同，来一记偷天换日

将\*p的后继节点的值赋予\*p，然后删除\*p的后继节点即可

如果\*p是**最后一个结点**时，就不能这么做了，此时只能从表头开始寻找

### 使用头插法建立单链表

该方法从空表开始(有头结点)生成新结点，然后将要插入的数据放到新结点中，使用相当于i=1的插值操作，将该结点插入至原链表中

:::tip
注意该方法生成的单链表为逆序，可以借助这点来实现**链表的逆置**

:::
### 使用尾插法建立单链表

若希望顺序与原数据一致，可以使用尾插法建立单链表。

该方法每次将要插入的结点插入至原链表的末尾，使用相当于i=length的插值操作

其时间复杂度与头插法相同

##