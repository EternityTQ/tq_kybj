---
title: 2.2 线性表的顺序表示
---
## 定义
![](/assets/img/2-2-1.jpg =300x)

顺序表：用顺序存储的方式实现线性表

即，用一组**地址连续**的存储单元，依次存储线性表中的数据元素，使得逻辑上相邻的两个元素在物理地址上也相邻

顺序表的特点是：**逻辑顺序与其存储的物理顺序相同**

顺序表的任意一个元素都可以**随机存取**

所以说线性表的顺序存储结构是一种随机存取的存储结构

设线性表第一个元素的存放位置是LOC(L)

则从表头开始，每个元素所存储的地址是

LOC(L)

LOC(L)+sizeof(elemtype)

LOC(L)+sizeof(elemtype)*2

....

一般而言，sizeof(int)=4B

顺序表的定义：

```c++
typedef struct {
	int data[Maxsize];
	int length;
}Sqlist;
```

注意，最好使用基本操作来操作数组！


顺序表的主要优点：

1. 可以进行**随机访问**，即可通过首地址和元素序号在O(1)时间内找到指定元素(data[i])
2. 存储密度高，每个节点只存储数据元素
   
缺点：
1. 元素的插入与删除需要移动大量元素，插入操作平均需要移动n/2个元素，删除操作平均需要移动(n-1)/2个元素
2. 扩展容量不方便
3. 顺序存储分配需要一段连续的存储空间，不够灵活
## 顺序表的创建


顺序表一般有静态分配和动态分配两种创建方式

对于静态分配而言，顺序表的表长一旦决定后，无法更改

动态分配由指针创建，若因插入元素导致空间不足，则进行再分配

## 顺序表的插入与删除

**插入操作** ListInsert(&L,i,e)：在表L中的第i个位置插入指定元素e

每插入一个元素，都得将插入位置i及以后的所有元素往后移1位

然后将顺序表的长度+1

注意顺序表的长度，避免非法数据，算法应当具有健壮性

\> 插入的时间复杂度

最好情况：新元素插入到表尾，T(n)=O(1)

最坏情况：新元素插入到表头，T(n)=O(n)

平均情况：T(n)=O(n)

**删除操作** ListDelete(&L,i,&e)：，删除表L中第i个元素e并返回

注意这里e是要返回的，要带引用符

每删除一个元素，将删除元素以后的所有元素往前移动1位
 
\> 删除的时间复杂度


最好情况：删除表尾元素，T(n)=O(1)

最坏情况：删除表头元素，T(n)=O(n)

平均情况：T(n)=O(n)

**插入和删除的时间主要耗费在移动元素上**

:::tip
注意位序i与数组下标的区别

伪代码中位序i从1开始，下标从0开始
:::

## 顺序表的按值查找

LocateElem(L,e)，在表L中查找具有给定关键字值的元素

\> 查找的时间复杂度


最好情况：查找元素就在表头，T(n)=O(1)

最坏情况：查找元素在表尾，T(n)=O(n)

平均情况：T(n)=O(n)

:::tip 关于时间复杂度平均情况的计算

详见复习资料P16

::: 


 
