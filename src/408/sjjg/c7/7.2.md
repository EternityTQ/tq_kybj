---
title: 7.2 顺序查找与折半查找
---

## 1. 顺序查找

顺序查找又称*线性查找*，适用于顺序表和链表

顺序查找通常分为对一般的无需线性表的顺序查找

和对按关键字有序的线性表的顺序查找

:::warning
不管采用什么算法，只要是顺序查找，其ASL就只与元素有关，而与顺序表是否有序无关
:::

### 1. 一般线性表的顺序查找

由于线性表无序，因此只能依次查找，时间复杂度固定位$O(n)$

:::tip "哨兵"
哨兵即在线性表的头部直接设置为待查找值，因此线性表的下标需要从1开始存储

直接由线性表尾部开始往头部比对，如果查找成功便直接返回下标

这样，一旦查找失败(即查找到头部)，则返回0

这种算法尽管无法降低时间复杂度，但是可以简化代码

:::

对于上述有哨兵的算法，即从尾部开始比对

若待查找元素为第i位，则需要查找$n-i+1$次

以此类推，第1位需要查找n次，第2位需要查找n-1次...第n位需要查找1次

如此形成等差数列，于是查找成功时，顺序查找的**平均长度**为

$$ASL_{\text{成功}}=\sum_{i=1}^n\color{red}P_i\color{black}(n-i+1)$$

这里的$P_i$是每个位置的查找概率，不可忽略

当$P_i=\frac 1n$时，有

$$ASL_{\text{成功}}=\sum_{i=1}^n\color{red}P_i\color{black}(n-i+1)=\frac{n+1}{2}$$

查找不成功时，比较次数为$n+1$

优点：对数据元素的存储没有要求，顺序和链式均可；对有序性也没有要求；对链表只能进行顺序查找

缺点：当n较大时，平均查找长度较大

### 2. 有序线性表的顺序查找

>这tm和上面那个有什么区别

即，从头开始查找，若线性表中没有待查找值的元素，则将会在第i个值发现关键字小于key，但是第i+1个值大于key，此时即可返回查找失败

可以用如下图的判定树来描述有序线性表的查找过程

![](/assets/img/shujv13.jpg)

:::tip
要注意这里的方框，即"失败结点"

失败结点是不存在的，是用来判定查找失败时的ASL的工具

这种利用失败结点判定平均查找时长的思想在后面的二叉树查找会用到
:::

共有n个成功结点，则相对应的有n+1个失败结点

因此，每个结点的查找次数为层高

平均查找长度就是($\sum$层高*每层个数)/结点个数

这里除了失败结点最后一层有2个以外，每一层均只有一个结点，所以每层个数为1

但这也解释了为什么上图的$ASL_{\text{失败}}$最后会有两个n

这种算法在查找成功时的ASL与无序顺序查找相同，但是查找失败时的ASL大大降低了

## 2. 折半查找

折半查找又称==二分查找==，它仅使用于有序的顺序表(不适用链表)

折半查找的核心思想：

1. 设置头尾两个指针，取中值向下取整为mid指针
2. 判断mid指针与key值的大小情况
3. 若key>mid，则说明key位于线性表较大的那一端，将low指针移向mid+1
4. 若key<mid，则说明key位于线性表较小的那一端，将high指针移向mid-1
5. 重复查找，直到找到key，或者确定线性表中没有key

:::tip
在选取mid指针时，通常使用向下取整，但亦可使用向上取整

但是要求算法整体均需采用一致的取整方式
:::

折半查找的过程可用如下图的二叉树来描述，称为*判定树*

![](/assets/img/shujv14.jpg)

:::warning
不能说折半查找和二叉排序树的时间性能相等，因为折半查找只能用其中一种二叉排序树来描述过程，但是二叉排序树的树形有很多种，最差的情况只有一条分支，这样的二叉排序树搜索时间复杂度为$O(n)$
:::

按照先前提过的做法，ASL的计算方式如下：

$$ASL=(\sum\text{层数}·\text{每层结点数})/\text{结点总数}$$

按照这个公式套到上面，即图中的结果

类似地，平均查找失败长度即统计失败结点的数目，注意数量和层数都和查找成功结点不同

同时还能从图中得出结论：$ASL_{\text{成功}}\leq h$

查找成功的平均查找长度为：

$$ASL=\frac 1n \sum_{i=1}^nl_i=\frac 1n(1·1+2·2+\cdots+h·2^{h-1})=\frac{n+1}{n}\log_2(n+1)-1\\\\≈log_2(n+1)-1$$

因此，最大查找次数为$\lceil \log_2(n+1)\rceil$

时间复杂度为$O(\log_2n)$

:::tip
折半查找要求线性表必须具有随机存取的特性，因此仅适用于顺序存储结构
:::

## 3. 分块查找

分块查找又称*索引顺序查找*，结合了顺序查找和折半查找各自的优点，既有动态结构，又使用于快速查找

分块查找的基本思想：

将查找表分为若干小块，块内的元素可以无序，但是每块之间的元素是有序的，即前一个块中的<u>最大关键字</u>小于后一个块中的<u>所有元素</u>

以此类推，再建立一个索引表，该表中包含各块中的<u>最大关键字</u>以及<u>第一个元素的地址</u>，索引表按照关键字有序排列

分块查找的过程分为两步：

+ 1. 在索引表中确定待查记录所在的块
+ 2. 在块内顺序查找

线性表的ASL可以分为索引查找和块内查找的平均长度之和

$$ASL=L_l+L_s$$

将长度为n的查找表均匀地分为b块，每块有s个记录(即$b=\frac ns$)

则有：

$$ASL=L_l+L_s=\frac{b+1}{2}+\frac{s+1}{2}=\frac{\frac ns+1}{2}+\frac{s+1}{2}\\\\
\space\\\\
=\frac{n+s}{2s}+\frac{s(s+1)}{2s}=\frac{s^2+2s+n}{2s}$$

:::tip
当$s=\sqrt{n}$时，则此时平均查找效率最高，为$\sqrt{n}+1$
:::

:::tip
可以考虑使用链式存储来提升动态效率，例如索引表与线性表之间的链接
:::













