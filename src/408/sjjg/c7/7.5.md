---
title: 7.5 散列表
---
## 1. 基本概念
:::tip
散列表又称**哈希表**
:::

特点是：数据元素与关键字与其存储地址直接相关

通过哈希函数建立关键字与存储地址的联系

**同义词**；通过散列函数映射到了同一个值

**冲突**：通过散列函数确定的位置已经存放了其他元素

需要选择合适的散列函数来减少冲突的情况，以此来减少ASL

最理想情况：时间复杂度为O(1)

查找成功的ASL：直接用二叉树的算法即可

查找失败的ASL：假设映射到所有地址的概率都是相同的，然后几个结点就几次就行了

:::tip
通过散列函数后对应存储地址没有存放元素的话，长度记为0，常见于拉链法，即存放的是空指针
:::

装填因子α：表中记录数/散列表长度，即查找失败的ASL

装填因子会直接影响散列表的查找效率


## 2. 常见的散列函数

设计目标：让不同关键字的冲突尽可能的少

### 1. 除留余数法

$H(key)=key \text{ mod } p$

p取不大于表长但最大的质数

### 2. 直接定址法

$H(key)=key\text{ or }H(key)=a*key+b$

适合关键字的分布基本连续的情况

若关键字分布不连续，就会造成浪费

### 3. 数字分析法

选取数码分布较为均匀的若干位作为散列地址

例如，用手机号码分布更均匀的后4位提取出来作为散列地址

### 4. 平方取中法

取关键字的平方值的中间几位作为散列地址

这种方法得到的散列地址和关键字的每位都有关系

## 3. 处理冲突的方法

### 1. 开放定址法

即存放表项的空闲地址既可以向同义词表项开放，又向它的非同义词表项开放

即，如果一个地址溢出了，可以存在隔壁

$$H_i=(H(key)+d_i)\text{ mod }m$$
:::tip
注意开放定址法的冲突处理数值域是关键字的散列表表长，但是哈希函数的数值域是根据哈希函数设定的，哈希函数值域通常小于等于冲突处理数值域

:::

:::tip
采用开放定址法时，删除结点不能简单地将被删结点的空间置空，否则会截断查找路径

可以加一个删除标记，进行逻辑上的删除
:::

:::danger
开放定址法中，空节点比较失败也算查找次数
:::

根据$d_i$的取值方法，有不同的定值方法
1. **线性探测法**

$d_i=0,1,2,3,\cdots,m-1$，即每次发生冲突时，每次往后探测相邻的下一个单元是否为空

考试爱考这个

查找失败的计算方法：查到末尾才算失败

**聚集(堆积)现象**：同义词与非同义词聚集在一起

2. **平方探测法**

当$d_i=0^2,1^2,-1^2,2^2,-2^2,\cdots,k^2,-k^2$，时，称为平方探测法，又称**二次探测法**

其中，$k\leq m/2$

比起线性探测法更不易产生堆积问题

:::tip
散列表的长度m必须是一个可以表示成$4j+3$的质数，才能探测到所有位置
:::

1. **双散列法**
   
$d_i=i*hash_2(key)$

探测序列等于另一个散列函数算出来的值

如果第二个散列函数计算得到的值与散列表表长互质，则可以确保双散列法可以探测所有单元


4. **伪随机序列法**

$d_i$是一个伪随机序列，如$d_i=0,5,24,11...$

### 2. 拉链法

拉链法：将所有同义词存储在一个链表中

即使用链表的方式依次存储同义词

散列表可以视为13个链表的头指针

每次插入时使用头插法插入至链表中

考试时默认头插

空指针查找失败时，不计算查找长度

删除时只需要顺序查找对应的链表即可，不需要加逻辑删除标记






