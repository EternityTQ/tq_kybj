---
title: 7.3 树形查找
---

## 1. 二叉排序树(BST)

构造二叉排序树的目的：提高查找、插入、删除关键字的速度

### 1. 二叉排序树的定义

二叉排序树可能是一棵空树，但大部分情况是符合下述特性的二叉树：

1. 若左子树非空，则左子树上的所有结点的值均小于根节点的值
2. 若右子树非空，则右子树上的所有结点的值均大于根节点的值
3. 左右子树也分别是一棵二叉排序树

:::tip
对二叉排序树进行中序遍历，就可以得到一个递增的有序序列
:::

### 2. 二叉排序树的查找

非递归的算法空间复杂度：$O(1)$

递归的算法空间复杂度：$O(h)$

将待查找值与根节点进行比较

若相等，则查找成功

若小于，则进入左子树

若大于，则进入右子树

### 3. 二叉排序树的插入

按照查找的算法进行查找插入位置，当查找到空值时，即为可插入的位置

需要注意若二叉排序树内存在与待插入值相等的元素，则插入失败


### 4. 二叉排序树的构造

即按照插入的算法进行多个点的插入即可

需要注意的是，一组确定的关键字序列，序列的顺序不同会影响到构造出来的二叉树树形


### 5. 二叉排序树的删除(重点)


删除二叉排序树时，要注意前后的顺序不能修改，否则会导致排序树的性质丢失

需要按照下列情况来处理：

+ 若被删除的结点是叶结点：直接删除，不会影响二叉排序树的性质
  
+ 若结点只有一棵左或右子树，则让该子树变为其父节点的子树，即接替原结点的位置

+ 若结点有完整的左右子树，则需要按照中序遍历找到该结点的直接前驱或者直接后继，使其替代结点z

    同时，符合条件的该结点必然只有一棵左子树或右子树，按照第二点操作即可

### 6. 二叉排序树的查找效率分析

二叉排序树的查找效率主要去取决于树形，若二叉排序树同时是一棵平衡二叉树，则其平均查找长度为$O(\log_2n)$。若二叉排序树时只有一颗左孩子或右孩子的单支树，则平均查找长度为$O(n)$

ASL的计算方式与先前提到的二叉树计算方式相同


## 2. 平衡二叉树
### 1. 平衡二叉树的定义

平衡二叉树，又称**AVL树**，规定任意一个根节点的左右子树深度差的绝对值不能大于1

**平衡因子**： 左子树-右子树的高度差

一棵符合规定的平衡二叉树的结点的平衡因子值只可能是-1、0、1

因此，平衡二叉树可定义为一棵空树，或是符合下列定义的树：

左子树与右子树均是平衡二叉树，且高度差的绝对值不大于1

### 2. 平衡二叉树的插入

基本思想：每当在树中插入一个结点时，首先需要检查其插入路径上的结点是否因为此次操作导致了不平衡。

如果是，找到最近的一个不平衡的结点，对其进行操作，调整各结点的位置关系，使之重新达到平衡

#### **LL型平衡旋转(结点右旋)**

由于在结点A的左孩子的左子树上插入了新结点，导致结点A出现了左失衡，结点A的平衡因子由1增至2，此时需要对A进行右旋，减少左左子树的高度

![](/assets/img/shujv16.gif)


#### **RR型平衡旋转(结点左旋)**

由于在结点A的右孩子的右子树上插入了新结点，导致结点A出现了右失衡，结点A的平衡因子由-1增至-2，此时需要对A进行左旋，减少右右子树的高度

![](/assets/img/shujv17.gif)

#### **LR型平衡旋转(先左再右)**

由于在结点A的左孩子的右子树上插入了新结点，导致结点A出现了左右失衡，需要进行两次旋转操作，先对结点A的左孩子进行左旋转，再对结点A进行右旋转

![](/assets/img/shujv18.gif)

#### **RL型平衡旋转(先右再左)**

由于在结点A的右孩子的左子树上插入了新结点，导致结点A出现了右左失衡，需要进行两次旋转操作，先对结点A的右孩子进行右旋转，再对结点A进行左旋转

![](/assets/img/shujv19.gif)

构造平衡二叉树的过程遵循上述步骤，一旦出现了失衡情况就要作及时调整

### 3. 平衡二叉树的删除

:::tip
省流：删完后需要一直向上找失衡结点

:::

删除操作与插入类似

1. 用二叉排序树的方法对结点w执行删除操作(无子树直接删，单子树拿儿子顶，双子树找前驱或后继)
2. 若导致了不平衡，则需要从结点w开始向上回溯，找到第一个失衡结点，对其进行平衡
:::tip 怎么平衡？
这里的失衡节点称作y

找y的大儿子和大孙子，根据形状判断是插入操作中的何种类型，然后套用流程即可
:::
3. 平衡完毕后，仍需要向上回溯，继续找到下一个失衡结点，直到确认根节点没有失衡为止

删除的时间复杂度：$O(\log_2n)$

考试不会靠有多种处理方式的题目

### 4. 平衡二叉树的查找

在平衡二叉树上进行查找的过程与二叉排序树相同

假设以$n_h$表示深度为$h$的平衡二叉树中，含有的最少结点数

显然，$n_0=1,n_1=1,n_2=2$，且有递推式：$n_h=n_{h-2}+n_{h-1}+1$

因此可以推出如下表所示，高度为h的平衡二叉树中拥有的最小结点树：

| h | num |
| - | --- |
| 0 | 0 |
| 1 | 1 |
| 2 | 2 |
| 3 | 4 |
| 4 | 7 |
| 5 | 12 |
| 6 | 20 |
| 7 | 33 |
| 8 | 54 |

:::tip
含有n个结点的平衡二叉树的最大深度为$O(\log_2n)$，平均查找效率为$O(\log_2n)$
:::

深度为h的平衡二叉树中含有的最多结点数显然是满二叉树的情况


## 3. 红黑树
:::tip 红黑树和平衡二叉树的区别
平衡二叉树对于树形平衡的要求非常苛刻，适用于查操作较多的情况

而红黑树对平衡的要求稍宽，更适用于增删结点较多的情况


:::

红黑树的定义、性质——选择题

红黑树的插入/删除——要能手绘插入过程

不太可能靠代码，较复杂

### 1. 红黑树的定义

红黑树是一棵二叉排序树

即：左<根<右

红黑树相比普通BST，增加了若干要求：

1. 每个结点要么是红色，要么是黑色
2. 根结点是黑色的
3. 叶结点(外部结点、NULL结点、失败结点)均是黑色的
4. 不存在两个相邻的红结点
5. 对每个结点，从该结点到任一叶结点的简单路径上，所含黑结点的数目相同
:::warning
叶结点不包括只有失败结点孩子的结点
:::

![](/assets/img/shujv15.jpg)

结点的黑高(bh)：从该结点出发，到达任一空叶结点路径上的黑结点总数

#### **二叉树的性质**
1. 从根节点到叶结点的最长路径不大于最短路径的2倍

2. 有n个内部节点的红黑树高度$h\leq 2\log_2(n+1)$

3. 红黑树查找时间复杂度=$O(\log_2n)$

### 2. 红黑树的查找

与BST、AVL相同，从根出发，左小右大，直到查找到目标结点，或查找到一个空叶结点

### 3. 红黑树的插入

1. 先查找，确定插入位置，插入新结点
2. 新结点是根，染为黑色
3. 新结点非根，染为红色
4. 若插入新结点后满足红黑树定义，则插入结束
5. 若插入新结点后不满足定义，则需要条件

:::tip 如何调整？
看新结点叔叔的脸色

叔叔即父结点的兄弟

如果叔叔是黑色，则旋转+染色

根据叔叔的父节点(即爷结点)和新结点来判定是哪一型

+ LL型：右单旋，父爷染色
+ RR型：左单旋，父爷染色
+ LR型：左右双旋，儿爷染色
+ RL型：右左双旋，儿爷染色

>和平衡二叉树的操作一样

染色操作：即对有更改结构的结点进行取反

如果叔叔是红色，则染色+变新
+ 叔父爷染色，爷变为新结点(按新结点的流程走一遍)
:::

### 4. 红黑树的删除
(太难了，不重要)

删除时间复杂度：$O(\log_2n)$

红黑树中删除结点的处理方式和二叉排序树的删除一样

删除结点后，可能破坏红黑树特性，此时需要调整结点颜色、位置，使其再次满足红黑树特性










