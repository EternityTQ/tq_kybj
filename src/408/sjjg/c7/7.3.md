---
title: 7.3 树形查找
---

## 1. 二叉排序树(BST)

构造二叉排序树的目的：提高查找、插入、删除关键字的速度

### 1. 二叉排序树的定义

二叉排序树可能是一棵空树，但大部分情况是符合下述特性的二叉树：

1. 若左子树非空，则左子树上的所有结点的值均小于根节点的值
2. 若右子树非空，则右子树上的所有结点的值均大于根节点的值
3. 左右子树也分别是一棵二叉排序树

:::tip
对二叉排序树进行中序遍历，就可以得到一个递增的有序序列
:::

### 2. 二叉排序树的查找

非递归的算法空间复杂度：$O(1)$

递归的算法空间复杂度：$O(h)$

将待查找值与根节点进行比较

若相等，则查找成功

若小于，则进入左子树

若大于，则进入右子树

### 3. 二叉排序树的插入

按照查找的算法进行查找插入位置，当查找到空值时，即为可插入的位置

需要注意若二叉排序树内存在与待插入值相等的元素，则插入失败


### 4. 二叉排序树的构造

即按照插入的算法进行多个点的插入即可

需要注意的是，一组确定的关键字序列，序列的顺序不同会影响到构造出来的二叉树树形


### 5. 二叉排序树的删除(重点)


删除二叉排序树时，要注意前后的顺序不能修改，否则会导致排序树的性质丢失

需要按照下列情况来处理：

+ 若被删除的结点是叶结点：直接删除，不会影响二叉排序树的性质
  
+ 若结点只有一棵左或右子树，则让该子树变为其父节点的子树，即接替原结点的位置

+ 若结点有完整的左右子树，则需要按照中序遍历找到该结点的直接前驱或者直接后继，使其替代结点z

    同时，符合条件的该结点必然只有一棵左子树或右子树，按照第二点操作即可

### 6. 二叉排序树的查找效率分析

二叉排序树的查找效率主要去取决于树形，若二叉排序树同时是一棵平衡二叉树，则其平均查找长度为$O(\log_2n)$。若二叉排序树时只有一颗左孩子或右孩子的单支树，则平均查找长度为$O(n)$

ASL的计算方式与先前提到的二叉树计算方式相同


## 2. 平衡二叉树


## 3. 红黑树
:::tip
红黑树更适用于增删结点较多的情况

而平衡二叉树更适用于查操作较多的情况
:::

红黑树的定义、性质——选择题

红黑树的插入/删除——要能手绘插入过程

不太可能靠代码，较复杂

### 1. 红黑树的定义

红黑树是一棵二叉排序树

即：左<根<右

红黑树相比普通BST，增加了若干要求：

1. 每个结点要么是红色，要么是黑色
2. 根结点是黑色的
3. 叶结点(外部结点、NULL结点、失败结点)均是黑色的
4. 不存在两个相邻的红结点
5. 对每个结点，从该结点到任一叶结点的简单路径上，所含黑结点的数目相同
:::warning
叶结点不包括只有失败结点孩子的结点
:::

![](/assets/img/shujv15.jpg)

结点的黑高(bh)：从该结点出发，到达任一空叶结点路径上的黑结点总数

#### **二叉树的性质**
1. 从根节点到叶结点的最长路径不大于最短路径的2倍

2. 有n个内部节点的红黑树高度$h\leq 2\log_2(n+1)$

3. 红黑树查找时间复杂度=$O(\log_2n)$

### 2. 红黑树的查找

与BST、AVL相同，从根出发，左小右大，直到查找到目标结点，或查找到一个空叶结点

### 3. 红黑树的插入
















