---
title: 8.3 交换排序
---

## 冒泡排序

属于基于交换的排序

根据两个元素关键字的比较结果来对换这两个记录的位置

冒泡排序就是从后往前，或从前往后，把最大或最小的元素放在队首或队尾，然后不再对其进行比较交换

平均时间复杂度：$O(n^2)$

可以使用链表

**算法稳定性：稳定**


## 快速排序

好像确实是最优秀的算法。。

就叫他指针掐架排序吧！

基本思想：在待排序表中选择一个元素，作为基准(通常取首元素)，通过一趟排序将待排序表划分为大于基准和小于基准的两部分，而基准元素放在了最终位置上

然后分别对两个分表重复该过程

用两个指针掐架

由右侧的high先移动，直到找到第一个小于基准值的元素，将其移动到low指针的位置(此时原本是基准值，被空出来了)，然后让low指针移动，找到第一个大于基准值的元素，移动到high指针的位置，然后重复该过程

直到两个指针相遇，这里就是基准值的最终位置

然后分治法，对左右子表一样沿用该过程

:::tip
每次分治排序后，都会有1个元素被确定最终位置

注意：如果第一次确定的元素在队首或队尾，则第二层遍历最多只能确定1个元素，因为只会分治一次排序(另一边没有)
:::

**初始序列有序/逆序时，效率最差**

时间复杂度：$O(n·\text{递归层数})$

最佳时间复杂度：$O(nlog_2n)$

最差时间复杂度：$O(n^2)$

空间复杂度：$O(\text{递归层数})$

最佳空间复杂度：$O(log_2n)$

最差空间复杂度：$O(n)$

**算法稳定性：不稳定**








