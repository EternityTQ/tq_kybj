---
title: 8.4 选择排序
---
选择排序：每一趟在待排序元素中选取关键字最小或最大的元素加入有序子序列

## 1. 简单选择排序

直接扫描整个表，选择最大或最小的元素，放在最前面

空间复杂度：$O(1)$

时间复杂度：$O(n^2)$

一定需要n-1趟处理，每次都要查找最值

**算法稳定性：不稳定**

## 2. 堆排序

**堆**：可以视为一棵层序存储的完全二叉树

![](/assets/img/shujv24.jpg)

**大根堆**：根$\geq$左、右

**小根堆**：跟$\leq$左、右

**堆排序**：将原始数组整理成堆的形式，然后按照二叉树层次遍历的思路进行排序

### 1. 建立堆

检查当前结点是否符合堆特性，如果出现了不符合大根堆或小根堆的结点，直接将当前结点与**更大的孩子****互换**即可

如果互换元素破坏了下一级的堆，则采用相同的方法继续向下调整(小元素不断下坠)

>类似AVL树删除结点向上不断检查的操作？

### 2. 堆排序

每一趟将堆顶元素加入有序子序列(与待排序序列的**最后一个元素**交换)，将已加入有序子序列的元素移出堆

然后再将待排序序列进行一次**建立堆**的操作，确保队首(树顶)元素是最值

:::tip
基于大根堆会得到升序递增序列，即每次输出剩余最大的元素，倒过来就是升序

基于小根堆会得到降序递减序列，同理
:::

建堆的过程，时间复杂度=$O(n)$

堆排序的时间复杂度：$O(nlog_2n)$

空间复杂度：$O(1)$

**算法的稳定性：不稳定**

:::tip
对于比较次数，每次向下移动都需要比对两次(一次是孩子之间的比对，一次是和孩子的比对)

向上移动只需要比对一次
:::



