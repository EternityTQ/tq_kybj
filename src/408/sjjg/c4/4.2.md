---
title: 4.2 串的模式匹配
---
>4.1不在大纲范围内，略！

## 1. 简单的模式匹配算法

子串——主串的一部分

模式串——待查找的字符串

其直接在主串中进行暴力搜索求解

即：
用俩指针

① 从头开始遍历主串

② 当当前遍历字符与模式串首字符相同时，进入匹配模式，从头到尾同时遍历主串和模式串

③ 若匹配成功，则返回

④ 若匹配失败，则主串的指针返回开始匹配的位置，继续往下遍历

最坏时间复杂度：O(mn)

## 2. KMP算法

即，当模式串开始匹配后的某一串字符不匹配时，匹配成功的部分一定是和模式串一致的

因此，要利用好前面已经匹配成功的部分，提高效率

也就是说，当主串匹配失败时，模式串不一定要回到初始状态，可以让模式串的指针跳转到中间的某个状态，来跳过所有一定不匹配的情况，提高效率

提高效率的方法仅依赖于模式串，与主串没有关系，

也就是说，需要有一个状态组，让模式串匹配失败时，通过这个状态组能快速回到上一个可以继续匹配的位置

优化之后，匹配失败时，主串不再需要回溯，而是让模式串直接回到对应的位置，大幅提高效率

用一个数组来记录这个状态组，这个数组成为next数组

next数组有一点需要注意，数组首位匹配失败时，主串和模式串指针都要++

KMP算法最坏时间复杂度是O(m+n)

其中，求next数组的时间复杂度是O(m)

next数组一般手动求即可

## 求next数组

next数组的作用：当模式串的第j个字符失配时，从模式串的第next[j]个字符继续往后匹配

### 手算

1. 第一个字符匹配失败时，只能继续往下匹配，所以next[1]无脑写0

2. next[2]无脑写1

3. 在不匹配的位置前划分界线，让模式串一步一步往后撤，如果能在分界线前找到n个与模式串前n个字符匹配的子串，则当前next值为n+1

例如：
| a | b | a | b | a | b | b | c |
| - | - | - | - | - | - |- |- |
| a | b | a | b | a | a | | |

此时下方的模式串到最后一个字符时匹配失败了，则其慢慢往后撤(其实就是往前挪)

| a | b | a | b | a | b | b | c |
| - | - | - | - | - | - |- |- |
|  |  | *a* | *b* | *a* | b | a | a |

挪到这个位置，发现斜体的部分与之前匹配上的字符可以继续匹配，那么next[6]=3+1=4

### 优化思路

重点检查next数组中指向的位置和当前指向的位置是否相同，如果是，则可以进行优化，减少检查次数

(在创建数组时没有这么检查)

优化后的数组即nextval数组

手算解题：先求next数组，再由next数组求nextval数组

1. nextval[1]=0

2. 如果next数组指向的数值和当前的数值一致，则当前next的值为next->nextval的值

否则不变

| 序号 | 1 | 2 | 3 | 4 | 5 | 6 |
| --- | - | - | - | - | - | - |
| 模式串 | a | b | a | b | a | a |
| next[j] | 0 | 1 | 1 | 2 | 3 | 4 |
| nextval[j] | 0 | 1 | 0 | 1 | 0 | 4 |









