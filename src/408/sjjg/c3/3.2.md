---
title: 3.2 队列
---

## 队列的基本概念

**逻辑结构**上，也是一种线性表

其只允许在一端进行插入，在另一段删除

插入元素称为*入队*或*进队*，删除元素称为*出队*或*离队*

其操作特性是**先进先出**(FIFO)

队头：允许删除的一端，又称队首

队尾：允许插入的一端

空队列：不含任何元素的空表

基本操作：

创建、销毁

增加、删除

查(基本只用查队头元素)



## 队列的存储结构

### 队列的顺序存储

队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：

:::warning
这里的指针是假设的情况，要注意题目中指针也有可能直接指向元素，这时候写法和判别方法都要进行改变
:::

对头指针front指向队头元素，队尾元素rear指向队尾元素的下一个位置(要插入数据元素的位置)

队列的顺序存储类型可以描述为：

```c
#define MaxSize 50

typedef struct{
    Elemtype data[MaxSize];
    int front,rear;

}
```

初始值：Q.front=Q.rear=0

进队操作：队不满时，先送值到队尾元素，再将队尾指针+1

出队操作：取队头元素，队头指针+1

注意当队尾元素达到Maxsize时，会出现"假溢出"的情况

即出现"上溢出"的情况，data仍然可以存储在空位置中

### 队列的循环存储

为了解决假溢出的情况，引出了循环队列的概念

此处将队列遐想为一个"循环空间"，将该表从逻辑上视为一个环，称为**循环队列**

当队首指针Q.front=Maxsize-1时，再前进一个位置就自动到0，此时可以利用取余运算
:::tip
**判断队空**：Q.front=Q.rear

注意，队尾指针rear在队首指针front之前

意思是人家跑的永远比front快

如果出现rear\<front的情况，那就是进循环啦！
:::
但是，当数组内所有地址全被填充元素后，此时Q.front一样会等于Q.rear，不好判断啊对不对

因此这里有三种处理方式来区别是对空还是队满：

1. 牺牲一个单元来区分对空还是队满，入队时少用一个队列单元，当队尾指针马上要追上队头指针，即还剩一个空位就满时，此时<b>(Q.rear+1)%Maxsize=Q.front</b>，视作队列已满。

>加粗那句居然会考。。

队列元素个数：(rear+MaxSize-front)%MaxSize

这也是比较常见的做法。

2. 定义中新增一个size数据成员，表示元素个数，根据这个来判断是否已满

>说实话我更喜欢这种

3. 定义中新增tag数据成员，表示最近进行的操作，用来区分队列是否已满，当删除元素时，置tag=0，若删除后导致Q.front=Q.rear，则此时队列为空

当插入元素时，置tag=1，若插入后导致Q.front=Q.rear，则此时队列已满

>这种也很妙啊我草

:::danger
注意辨析队尾指针指向的元素，辨析算法写法
:::

## 队列的链式存储结构

队列的链式表示称为**链队列**

队列相当于单链表的阉割版。

队列的链式存储类型可描述为：

```c
typedef struct LinkNode{
    ElemType data;
    struct LinkNode *next;
}LinkNode;

typedef struct{
    LinkNode *front,*rear;
}LinkQueue
```

注意需要布置一个额外的尾指针，用来指向插入元素的队尾节点

判断是否空队列：

rear和front指向NULL

用单链表表示的链式队列适合于数据元素变动比较大的情形，而且**不存在队列满**且产生溢出的问题

入队：
```c
s->data=x;
s->next=NULL;
Q.rear->next=s;
Q.rear=s;

```
出队：
```c
if(Q.front==Q.rear)
    return false; //空队
LinkNode *p=Q.front->next;
x=p->data;
Q.front->next=p->next;
if(Q.rear=p)
    Q.rear=Q.front;
free(p);
return true;
```

## 双端队列

*双端队列*是指允许两段都可以进行插入、删除的线性表

输入受限的双端队列：只允许在一端输入

输出受限：只允许在一端输出

**考点：判断输出序列合法性**







