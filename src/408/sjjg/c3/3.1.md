---
title: 3.1 栈
---
## 栈的定义

栈(stack)是<u>只允许在一端</u>进行插入或删除操作的**线性表**

栈顶(top)：线性表中允许进行插入删除的那一端

栈底(bottom)：固定的，不允许进行插入删除的那一端

空栈：不含任何元素的空表

假设有某个栈S，进栈顺序为$a_1,a_2,a_3,a_4,a_5$，则栈顶元素是$a_5$，栈底元素是$a_1$，出栈次序为$a_5,a_4,a_3,a_2,a_1$

栈的操作特性可以被概括为**后进先出**(LIFO, last in first out)

## 栈的基本操作

初始化、销毁

push(&S,x) 进栈

pop(&S,&x) 出栈，弹出**栈顶**元素

GetTop(S,&x) 读栈顶元素

如果有n个不同元素进栈，则出栈元素的不同排列个数为$\frac{1}{n+1}C^n_{2n}$

## 顺序栈

代码定义：
```c
#define MaxSize 10
typedef struct{
    Elemtype data[Maxsize];  //静态数组存放栈中元素
    int top;  //栈顶指针
}SqStack

void InitStack(SqStack &S){
    S.top=-1;
}
```

栈顶元素即S.data[S.top]

进栈操作：栈不满时，栈顶指针先+1，再送值至栈顶

S.data[++S.top]=x;

判栈空：S.top==-1

栈满条件：S.top==MaxSize-1

出栈：x=S.data[S.top--]

:::tip
当S.top指向栈顶元素的下一个元素时，初始化S.top为0，然后需要注意辨析其他操作
:::

顺序栈的缺点：栈的大小不可变

## 共享栈

使两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设在共享空间的两端，当两个栈指针相邻(top1-top0=1)时，判断为栈满

其能更好的利用存储空间，减少发生上溢的可能

所有操作的时间复杂度都是$O(1)$

## 链式栈

采用链式存储的栈称为*链栈*，其优点是便于多个栈共享存储空间及提高其效率，且不存在栈满上溢的情况

链栈通常采用单链表来实现，规定所有的操作都是在单链表的表头进行的，同时规定链栈没有头结点








