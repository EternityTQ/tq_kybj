---
title: 5.2 二叉树的概念
---

## 1.二叉树的基本概念

二叉树是n个结点的有限集合

1. 可以是空二叉树，即n=0
2. 主要由一个根节点和两个互不相交的，被称为根的左子树和右子树组成。

左子树和右子树又分别是一颗二叉树

特点：1. 每个结点至多只有两颗子树；2. 左右子树不能颠倒(是有序树)

:::tip 二叉树和度为2的有序树的区别
1. 后者至少有3个结点，前者可以为空
2. 度为2的有序树的左右次序是相对另一个孩子而言的，若一个结点只有一个孩子，则无需区分左右次序；但是二叉树的左右次序是确定的，不可变更的
:::

## 2. 几种特殊的二叉树


### 1. 满二叉树
一颗高度为h，且含有$2^h-1$个结点的二叉树

![](/assets/img/shujv3.jpg =400x)

特点：
1. 只有最后一层有叶子结点
2. 不存在度为1的结点
3. 按层序从1开始编号，结点i的左孩子为2i，右孩子的编号为2i+1，结点i的父节点为[i/2]

### 2. 完全二叉树
当且仅当每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树

![](/assets/img/shujv4.jpg =400x)

即，完全二叉树是满二叉树中删除部分连续的编号较大的结点

满二叉树一定是完全二叉树，但是完全二叉树不一定是满二叉树

特点：
1. 只有最后两层可能有叶子结点
2. **最多只有一个度为1的结点**
3. 同上(3)
4. $i\leq[n/2]$为分支结点，$i>[n/2]$为叶子结点

### 3. 二叉排序树(很重要)
1. 左子树上所有结点的关键字均小于根节点的关键字
2. 右子树上所有结点的关键字均大于根节点的关键字
3. 左子树和右子树分别也是一颗二叉排序树

### 4. 平衡二叉树
树上任意节点的左子树和右子树的深度之差不超过1

可以提高搜索效率

## 3. 二叉树的性质

1. 非空二叉树上的叶节点数等于度为2的结点数加1，即$n_0=n_2+1$(**很重要**)




其他性质在前面5.1有提到了

对于完全二叉树而言：
1. 具有n个结点的完全二叉树的高度h为$\lceil \log_2(n+1)\rceil$或$\lfloor \log_2n\rfloor+1$

2. 对于完全二叉树，可以由结点树n推出度为0,1,2的结点个数

完全二叉树最多只有一个度为1的结点

$n_1=0\text{ 或 }1$

$n_0=n_2+1 \to n_0+ n_2 \text{一定是奇数}$

如果完全二叉树共有2k个结点，则必有：

$n_1=1,n_0=k,n_2=k-1$

反之，如果有2k-1个结点，则：

$n_1=0,n_0=k,n_2=k-1$

## 4. 二叉树的存储结构

### 1. 顺序存储

用一组连续的存储单元，依次自上而下、自左至右存储完全二叉树的结点元素

依据二叉树的性质，完全二叉树和满二叉树采取顺序存储比较合适，序号能反映结点之间的逻辑关系

但是对于一般的二叉树，只能添加一些不存在的空结点，使其与完全二叉树上的结点一一对照，但是很浪费空间

几个重要常考的基本操作：
1. i的左孩子 —— 2i
2. i的右孩子 —— 2i+1
3. i的父节点 —— [i/2]
4. i所在的层次 —— $\lceil \log_2(i+1)\rceil$

:::tip 关于数组下标
此处数组下标最好从1开始，保证数组下标和结点编号一致
:::

实际上很少使用顺序存储的方式

### 2. 链式存储

二叉树一般都采用链式存储结构，用链表结点来存储二叉树中的每个结点

在每个结点中，二叉链表至少包含3个域：数据域data，左指针域lchild和右指针域rchild

二叉树的链式存储结构描述如下：

```c++
typedef struct BiTNode{
    ElemType data;
    struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;
```

一般可能会有存储结构带父指针，但大多数没有

在含有n个结点的二叉链表中，含有n+1个空链域(即没有指针的指针域)(**很重要**)

:::tip 卡特兰数
给定n个结点，求有多少个符合形态的二叉树，这个符合卡特兰数的定义

先标记一下，之后回来补充定义

卡特兰数前几项分别为：

1,1,2,5,14,42,132,429,1430

(从下标0开始)
:::









