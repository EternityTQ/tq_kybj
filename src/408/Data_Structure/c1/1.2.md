---
title: 1.2 算法与算法评价
---

## 算法的基本概念

算法是对**特定问题求解步骤的一种描述**，是指令的**有限**序列

数据结构是要处理的信息

算法是处理信息的**步骤**

一个算法**必须**具有以下5个特性：
+ 有穷性：必须要在**有穷步**之后**结束**，每一步都要在有穷时间内完成
+ 确定性：每条指定都必须要有**确切的含义**，对于相同的输入只能得到相同的输出
+ 可行性：算法描述的操作都可以通过**基本运算执行有限次**来实现
+ 输入：一个算法有零个或多个输入，这些输入取自于某个特定对象的集合
+ 输出：一个算法有一个或多个输出，这些输出多与输入有着特定关系的量

:::tip 算法与函数
算法就好比y=f(x)

x是输入，f()是过程，y是输出
:::

一个**好算法**通常还应**考虑**达到以下目标：

1. 正确性：算法应当能够正确地求解问题
2. 可读性：算法应当有良好的可读性，帮助人们理解，可以用注释来提高可读性
3. 健壮性：算法能对输入中的非法数据作出反应或处理，而不会产生对应的非法输出
4. 高效率与低储存量需求：即时间复杂度与空间复杂度都要低

## 时间复杂度

事前预估算法时间开销T(n)与问题规模n的关系(T -> Time)

时间复杂度主要分析T(n)的**数量级**

即，保留总频数和中，阶数最高的一项

算法的时间复杂度即为`T(n)=O(f(n))`

其中，O的含义为T(n)的**数量级**

加法规则：多项相加，只保留最高阶的项，且系数变为1

T(n) = T~1~(n)+T~2~(n) = O(f(n)) + O(g(n)) = O(max(f(n),g(n)))

乘法规则：多项相乘，均保留

T(n) = T~1~(n)\*T~2~(n) = O(f(n)) \* O(g(n)) = O(f(n)\*g(n))

渐进时间复杂度：

O(1) < O(log~2~n) < O(n) < O(nlog~2~n) < O(n^2^) < O(n^3^) < O(2^n^)< O(n!) < O(n^n^)
 

:::tip 关于大小排序速记
可以用：常对幂指阶

即：**常数**小于**对数**小于**幂函数**小于**指数函数**小于**阶乘**
:::

最坏时间复杂度是指在最坏情况下，算法的时间复杂度
平均时间复杂度是指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间

### 分析代码的时间复杂度

结论：

1. 顺序执行的代码只会影响常数项，可以忽略
2. 只需挑循环中的一个**基本操作**，分析它的执行次数与n的关系即可
3. 如果有多层嵌套循环，只需关注最深层循环执行了几次即可

## 空间复杂度

S(n)=O(n)

S即Space

只需关注存储空间大小与问题规模相关的变量

同样只需要关注**数量级**

例如int flag[n][n]，就是则S(n)=O(n^2^)

函数递归调用也会带来额外内存开销 

对于递归来说，空间复杂度一般是递归调用的深度

函数原地工作就是指算法所需的辅助空间为常量，S(n)=O(1)

空间复杂度的大小排序同样符合常对幂指阶